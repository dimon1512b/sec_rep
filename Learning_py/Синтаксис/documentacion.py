'''
Порядок действий при создании сайта, приложения в сайте и далее...

- Создать виртуальное окружение. Если не установлено то установить с помощью команды pip install virtualenv

- Зайти в папку с проектом и запустить там виртуальное окружение virtualenv myenv(Это название виртуального окружения)

- Запустить вирт окруж файлом который находится в
\деректория проекта\myenv(Это название виртуального окружегния)\Scripts\activate.bat

- Нужно использовать requirements.txt для установки всех зависимостей в проекте python pip freeze > requirements.txt

1. Установить питон

2. Установить интерпритатор

3. pip install django

4. Создать папку в которой будет проект

5. Создать проект в соотведственной папке и сразу дать ему название. В терминале нужно сразу находиться в папке будущего
проэкта и вызвать команду django-admin startproject mysite последнее - название

6. Запуск сервера делается командой python manage.py runserver для этого в терминале нужно опять же находиться
в той папке в которой находится файл manage.py

7. Создать приложение можно командой python manage.py startapp main

8. После создания приложения его сразу необходимо зареестрировать в settings.py добавив новый элемент в список
INSTALLED_APPS таким образом 'название_приложения'.

9. Далее чтобы начать отслежевать переходы пользователя по определенным url адресам нужно в главном файле
urls.py для этого в список urlpatterns нужно добавить новый метод path и аргументами передать сначало '' это будет
значить переход пользователя на главную страницу(если это не главная страница, а например страница 'about'
то указываем не '' a 'about'), а вторым аргументом передать то приложение которому мы какбы передаем полномочия
по показу каких-то данных пользователю. Для этого нужно сначало подключить дополнительный метод include через
запятю после path. Итак вторым аргументом передаем метод include у которого указываем аргументом 'приложение.urls'
говоря о том что полномочия будут переданы именно указанному приложению и файлу в нем urls.py следовательно
для этого нужно создать такой файл в нашем приложении. В созданом файле urls.py нашего приложения нужно создать список
urlpatterns и подтянуть метод path через from django.urls import path

10. Дальше чтобы продолжить отслежевать url адреса и делать какое-то поведение в реакцию на переход пользователя нужно
в файле прилодения urls.py в список шаблонов добавить следующее перенаправление. Тоесть добавляем элемент метод path,
первым аргументом указываем '' а вторым указываем views.метод_в_файле_views
(типо именно на этот файл и этот метод файла мы направляем поведение дальше для отображения контента на странице для
пользователя). Соответственно в файле views нужно прописать такой метод как def метод(request): pass Также обязательно
ещё подтянуть этот модуль в файл urls.py нашего приложения посредством from . import views

11. Именно внутри метода "метод" мы скажем что конкретно мы покажем нашему пользователю при переходе на главную страницу
В файле views.py подтягиваем класс HttpResponse from django.http А в методе index указываем принимаемый аргумент
request в теле функции пишем return HttpResponse('<h1>Проверка работы</h1>'). Это вариант вывода на экран для
пользователя только вручную вписанных строк. Но лучше в внутри метода index возвращать метод render(request,
'папка_с_файлом/name_html_file.html') чтобы отображать целый html файл или шаблон.

12. Html файл нужно хранить в новой специально созданной папке templates которая должна распологаться в папке приложения
а в самой папке templates должна быть папка с названием приложения а уже в ней html файлы

13. Для ясности и примера создадим ещё одно отслежевание в файле urls.py Для этого в список шаблонов доавляем новый
метод path и первым аргументом укажем "about" вторым укажем метод в файле views а именно метод views.about и
соотведственно в файле вьюс создаем новую функцию такую же как и index но с новым названием и текстом возврата

14.python manage.py migrate
Команда migrate просматривает настройку INSTALLED_APPS и создает все необходимые таблицы базы данных в
соответствии с настройками базы данных в вашем файле mysite/settings.py и миграциями базы данных, поставляемыми
с приложением



Шаблонизатор Jinja!!!
1. Создаем отдельный файл html который будет основным шаблоном для многих следующих файлов html
2. В него вписываем основной html код ктоторый необходим во всех следующих хтмл файлов.
3. Но в тех местах которые нужно будет изменять ставим специальную конструкцию {%block name%}{%endblock%} название
блоков должно быть разным.
4. Затем в самих файлах наследниках вначале необходимо указать основной файл от которого наследуемся с помощью
конструкции {% extends 'main/layout.html' %}
5. Затем когда мы определили файл от которого будем наследоваться необходимо заполнить контент в специальных блоках
через конструкцию {% block title %}Главная страница{% endblock %}.
6. Можно в любой участок кода вставлять содержимое другого хтмл файла через конструкцию {%include 'main/test.html'%}
и получиться что в этот участок кода вставится все содержимое подключаемого файла
7. Чтобы указать что мы подключаемся к папке со статическими файлами необходимо воспользоваться следующей конструкцией
{% load static %} и эту запись необходимо вписать в самый верх шаблонного файла
Также шаблонизатор джинжа передает не только файлы и шаблоны но и любые данные. Можно делать такие конструкции как
{% for i in range(100) %}
	<p>{{ i }}</p>
{% endfor %}
и мы получим вывод чисел до 100 на нашей странице
или такое:
{% for el in somedict %} # двоеточие ставить не нужно
	{% if el == 'value' %}
		<p>{{ el }}</p> # Блочные отступы
	{% endif %} # Всегда нужно закрывать
{% endfor %}
Привычные нам методы и функции языка питон в шаблонищаторе джинжа переопределены и используються по другому. Например:
{% for el in list %} # двоеточие ставить не нужно
	{% if el == 'value' %}
		{% filter upper %} # переводит все элементы в верхний регистр
			<p>{{ el }}</p> # Блочные отступы
		{% endfilter %}
	{% endif %} # Всегда нужно закрывать
{% endfor %}
Тоесть так сказать функции в джинже называються фильтрами
Так же этот фильтр можно вставить в тэг и это вполне вроде как полезно:
<h1>{%filter lower%}ТЕКСТ КОТОРЫЙ БУДЕТ В НИЖНЕМ РЕГИСТРЕ ИЗ-ЗА Фильтра{%endfilter%}</h1>
Если фильтр нужно применить к конструкции {{ some element }}
то делается это через вертекальную палочку {{ some element|upper }} ==> SOME ELEMENT


СТАТИЧЕСКИЕ ФАЙЛЫ!!!

1. Все статические файлы буть то JS файлы, CSS файлы, фото, видео, аудио - их нужно хранить в спецальной папке
которая называется static и лежит внутри приложения.
2. Внутри папки Статик нужно создать папку по названию приложения
3. Внутри папки которая была создана последняя по названию приложения - нужно создать ещё папки в соотведствиями с
типами файлов. Например css, img, js
4. Также для подключения и коректной работы статических файлов необходимо добавить элемент в основной список
urlpatterns и этот элемент это static(settings.STATIC_URL, document_root=settings.STATIC_ROOT) но для этого нужно
обязательно подтянуть следующие модули
from django.conf import settings
from django.conf.urls.static import static
5. Также необходимо в основном файле settings.py в конце добавить переменную
STATICFILES_DIRS = [
    BASE_DIR / 'static'
]
6. В хтмл файл статика подключается таким макаром : <link rel="stylesheet" href="{%static 'main/css/main.css'%}">
7. Картинки нужно подключать так: В верху главного шоблона хтмл - {% load static %}
В месте где должна быть картинка - <img src="{% static 'img/second_image.jpg' %}"

ПЕРЕДАЧА ДАННЫХ В ХТМЛ ШАБЛОН!!!

1.В файле views.py нашего приложения выбираем функцию которая перенаправляет нас на необходимый html файл и в
возврате той функции добавляем третий параметр метода render и этот параметр это словарь. Этот словарь можно создать
сразу в теле самой функции и внести в него пары "ключ":"значение" и значением будет именно данные которые мы
подтянем по ключу в наш хтмл файл. Подтянуть эти данные можно через конструкцию {{ ключ }} в необходимом теге.
Можно также пользоваться конструкциями шаблонизатора джинжа описанными выше



БУТСТРАП!!!!

CSS фраймоврк который обеспечевает нас готовыми стилями которые мы можем использовать для создания красивого дизайна
на нашем сайте
1. Его нужно подключить к нашему сайту bootstrapcdn.com >>> копируем ссылку css
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
2. В шаблонном файле в теге ХЕД вписываем тег link с атрибутом ссылки href и вставляем туда ссылку. Ещё можно указать
атрибут rel со значением stylesheet
3. Далее необходимо создать и подключить наш css файл. собственный. Для этого также невероятно важно подключить папку со
статическими файлами в самом верху шаблонного файла с помощью конструкции {% load static %}
4. А в теге ХЕД шаблонного файла подключаем его вручную через тег link
<link rel="stylesheet" href="{%static 'main/css/main.css'%}">



https://html5book.ru/html-tags/ - ссылка на список всех возможных тегов



РАБОТА С БАЗАМИ ДАННЫХ & Модели:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

1. В первую очередь нам необходимо внутри нашей базы данных создать новую таблицу. Внутри этой таблицы мы будем хранить
полностью все наши данные приложения и дальше из этой таблицы мы будем получать эти данные и отображать на странице.
Чтобы создать новую таблицу нам необходимо работать с файлом models.py
2. Чтобы создать таблицу в базе данных нужно создать класс который будет из себя представлять модель. А модель в свою
очередь это определенная таблица в базе данных. И через эту модель мы можем полностью управлять самой таблицей
в базе данных
3. Создаем класс который может называться как угодно. В качевстве того кого будем наследовать указываем models.Model
4. Дальше нам нужно прописать поля. Каждое поле будет как отдельное поле внутри таблицы. Поля представляют из себя
атрибуты класса. Например я хочу хранить данные о name and surname персоны. Я назову класс Person(models.Model):
и укажу соотведственно атрибуты класса как поля таблици которые будут содержать необходимые данные:
 name = models.CharField(max_length=20) # Поле в котором будут данные о имени персоны
 surname = models.CharField(max_length=20) # Поле в котором будут данные о фамилии персоны
 age = models.IntegerField()

 def __str__(self): # - этот метод нужен для того чтобы в
 админке наши посты отображались как список имен, а не список id.
    return self.name

5. Следующее что нужно сделать это создать миграцию нашей модели. Миграция это синхронизация нашего проекта с базой
данных. Прежде чем выполнить миграции нужно создать файлы миграции через команду python manage.py makemigrations.
После этого создастся файл миграции который будет описывать определенную таблицу в базе данных
6. Далее чтобы выполнить миграции нужно прописать команду python manage.py migrate
7. Далее нужно зарегестрировать наши модели в файле admin.py и подключить админку
8. Для этого в файле admin.py нашего приложения нужно вписать следующее:
from django.contrib import admin
from .models import "Название класса модели"

class "Название класса модели желательно"Admin(admin.ModelAdmin):
    pass

admin.site.register("Название класса модели", "Название класса что чуть выше")
Что мы сделали - импортировали нашу модель ...  и зарегистрировали ее в админке.
9. Далее нужно поработать с панелью администратора. Для этого в наш нужно перейти по юрл адресу admin
10. Чтобы войти в панель администартора необходимо сначала зареестрироваться и этим создать администратора.
Для этого нужно использовать команду python manage.py createsuperuser
11. Далее нужно сделать вьюху. Тоесть так чтобы это все было подвязано под хтмл файл. Открываем views.py приложения:
Добавляем туда:
from django.views import View
from .models import "Название класса модели"



CharField - это просто однострочное текстовое поле для ввода любых символов.
Аналогично input в html. По умолчанию вам надо указывать его длину.
SlugField - это тоже однострочное текстовое поле, но именно для адресов (об этом позже).
TextField - это многострочное текстовое поле, как textarea в html.
ImageField - специальное поле для загрузки картинок.
DateField - специальное поле для хранения даты.
ForeignKey - поле определяюще связь Один ко Многим (об этом позже).
А для использования ImageField нужно установить библиотеку pillow. Давайте сделаем это. Для этого наберите команду

pip install pillow

СВЯЗИ МЕЖДУ МОДЕЛЯМИ!!!

1. Для связи полей используется класс models.Foreinkey()
2. Есть 3 типа связей:
	а) Many-to one(найболее распостраненная, удобная и подходит под много кейсов) - многие к одному. В том случаее если
	нужно указать что у многих автомобилей есть один произваодитель или у одного покупателя может быть много товаров.
	Итак, чтобы указать в модели заказов поле покупателя нужно создать переменну user. Это будет именно та модель
	Юзера которая уже уже есть в Джанго изначально. И нашу модель с продажами мы связываем с моделью пользователей
	осуществляющих эти продажи. user = models.Foreinkey(User) "from django.contrib.auth.models import User"
	Для каждой связи "многие к одному" через поля Foreinkey обябзателен второй аргумент on_delete = models.???
		1. on_delete = models.SET_NULL - Когда мы удаляем пользователя - во всех заказах с которыми связан
		пользователь в поле Юзер будет проставлено пустое значение
		2. on_delete = models.CASCADE - Все заказы связанные с пользователем тоже будут удалены
		3. on_delete = models.PROTECT - Джанго не позволит нам удалять пользователя до тех пор пока у нас есть
		связанные с ним заказы
	Джанго не будет знать какого же юзера создать тем моделям которые уже были созданы. Чтобы не возникало с эти
	проблем нужно указать третий параметр - null=True. Тогда уже все созданные ранее заказы получат пустого
	пользователя и мы уже сами присвоем пользователя какого захотим
	б) Many-to many - многие ко многим. Данная связь может использоваться когда например есть модели с пиццами и
	ингридиентами для пиццы. Типо для каждой пиццы могут использоваться разные ингридиенты и наоборот. Поэтому можем
	например в модели с пиццами указать поле ingredients = models.ManyToManyField(Ingridients_class) первым
	аргументом нужно указать ту модель с которой будем связывать нашу модель с пиццами, которую ещё конечно же нужно
	импортировать
	в) One-to one - один к одному - По сути это просто какоето расширение имеющейся модели.
	Например модель Юзер. Имеет поля имени, фамилии и тд. А если нам хочется добавить какое-то новое поле для этого
	юзера то нужно связать модель Юзер с моделью где будет это поле. Создаем модель нового поля. Можно предварительно
	даже создать новое приложение
		class New_Field_For_User(models.Model):
			user = models.OneToOneField(User, on_delete=models.PROTECT)
			new_field = models.CharField(max_length=100)

			def __unicode__(self):
				return self.user
	Далее только проводим махинации в админке этой модели и готово:
		# -*- coding:utf-8 -*-
		from django.contrib import admin
		from django.contrib.auth.admin import UserAdmin
		from django.contrib.auth.models import User
		from .models import New_Field_For_User


		class UserInline(admin.StackedInline):
			model = New_Field_For_User
			can_delete = False
			verbose_name_plural = 'Доп. информация'


		# Определяем новый класс настроек для модели User
		class UserAdmin(UserAdmin):
			inlines = (UserInline,)


		# Перерегистрируем модель User
		admin.site.unregister(User)
		admin.site.register(User, UserAdmin)
'''




